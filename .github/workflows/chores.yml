name: Chores

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

env:
  COVERAGE_REPO: ${{ vars.COVERAGE_REPO || 'decisiveai/platform-health' }}
  REPO_NAME: ${{ github.event.repository.name }}

jobs:
  lint:
    name: Lint on Ubuntu
    runs-on: ubuntu-latest
    steps:
      - name: Clone the code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Download dependencies
        run: go mod download

      - name: Run linter
        uses: golangci/golangci-lint-action@v8
        with:
          install-mode: "binary"
          version: "latest"

  check-go-file-changes:
    name: Check if Go files changed
    runs-on: ubuntu-latest
    needs: lint
    outputs:
      go_files_changed: ${{ steps.check.outputs.go_files_changed }}
    steps:
      - name: Clone the code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine base commit
        id: base
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_COMMIT="${{ github.event.pull_request.base.sha }}"
          else
            BASE_COMMIT=$(git rev-parse HEAD~1)
          fi
          echo "BASE_COMMIT=$BASE_COMMIT" >> "$GITHUB_ENV"

      - name: Check for Go-related file changes
        id: check
        run: |
          git fetch origin main
          CHANGED_FILES=$(git diff --name-only "$BASE_COMMIT" HEAD -- '**/*.go' 'go.mod' 'go.sum' '*.go' | grep -vE '^vendor/' || true)

          if [[ -z "$CHANGED_FILES" ]]; then
            echo "No relevant Go file changes detected."
            echo "go_files_changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "Relevant Go file changes detected."
            echo "go_files_changed=true" >> "$GITHUB_OUTPUT"
          fi

  test:
    name: Test on Ubuntu
    runs-on: ubuntu-latest
    needs: [lint, check-go-file-changes]
    if: needs.check-go-file-changes.outputs.go_files_changed == 'true'
    steps:
      - name: Clone the code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Running Tests
        run: |
          go mod vendor
          go mod tidy
          CGO_ENABLED=0 go test -cover -coverprofile=coverage.out -mod=vendor -v -count=1 ./...

      - name: Archive code coverage results
        uses: actions/upload-artifact@v4
        with:
          name: code-coverage
          path: coverage.out

  report-coverage:
    name: Report code coverage
    runs-on: ubuntu-latest
    needs: [test, check-go-file-changes]
    if: github.event_name == 'pull_request' && needs.check-go-file-changes.outputs.go_files_changed == 'true'
    permissions:
      contents: read
      actions: read
      pull-requests: write
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Clone the code
        uses: actions/checkout@v4

      - name: Download current coverage
        uses: actions/download-artifact@v4
        with:
          name: code-coverage
          path: .

      - name: Find and download baseline breakdown
        run: |
          # Look for latest main.breakdown artifact
          ARTIFACT=$(gh api "repos/${{ github.repository }}/actions/artifacts" \
            --jq '[.artifacts[] | select(.name=="main-breakdown" and .workflow_run.head_branch=="main")] | sort_by(.updated_at) | last')
          
          if [[ "$ARTIFACT" != "null" && -n "$ARTIFACT" ]]; then
            echo "Found baseline breakdown artifact"
            RUN_ID=$(echo "$ARTIFACT" | jq -r '.workflow_run.id')
            gh run download $RUN_ID --name=main-breakdown --dir=baseline || echo "Download failed, proceeding without baseline"
          else
            echo "No baseline breakdown found, proceeding without baseline"
          fi

      - name: Check test coverage with diff
        id: coverage
        uses: vladopajic/go-test-coverage@v2
        continue-on-error: true
        with:
          config: ./.github/.testcoverage.yml
          profile: coverage.out
          diff-base-breakdown-file-name: ${{ hashFiles('baseline/main.breakdown') != '' && 'baseline/main.breakdown' || '' }}

      - name: Post coverage report as comment
        run: |
          COMMENT_ID=$(gh api repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments \
            --jq '.[] | select(.user.login=="github-actions[bot]" and (.body | contains("go-test-coverage report:"))) | .id' \
            | head -n 1)

          COMMENT_BODY="go-test-coverage report:
          \`\`\`
          ${{ fromJSON(steps.coverage.outputs.report) }}
          \`\`\`"

          if [ -z "$COMMENT_ID" ]; then
            echo "Creating new coverage comment"
            gh pr comment ${{ github.event.pull_request.number }} --body "$COMMENT_BODY"
          else
            echo "Updating existing coverage comment (ID: $COMMENT_ID)"
            gh api -X PATCH repos/${{ github.repository }}/issues/comments/$COMMENT_ID \
              -f body="$COMMENT_BODY"
          fi

  main-coverage:
    name: Generate and publish coverage on main
    runs-on: ubuntu-latest
    needs: [test]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Clone the code
        uses: actions/checkout@v4

      - name: Download coverage artifact
        uses: actions/download-artifact@v4
        with:
          name: code-coverage
          path: .

      - name: Generate test coverage report and breakdown
        id: coverage
        uses: vladopajic/go-test-coverage@v2
        with:
          config: ./.github/.testcoverage.yml
          profile: coverage.out

      - name: Upload breakdown as baseline for future diffs
        uses: actions/upload-artifact@v4
        with:
          name: main-breakdown
          path: main.breakdown

      - name: Save coverage report to file
        run: |
          echo '${{ fromJSON(steps.coverage.outputs.report) }}' > coverage-${REPO_NAME}.txt

      - name: Publish coverage to remote repository
        env:
          GH_TOKEN: ${{ secrets.COVERAGE_REPO_TOKEN }}
        run: |
          # Clone the coverage repository
          git clone https://x-access-token:${GH_TOKEN}@github.com/${COVERAGE_REPO}.git coverage-repo
          cd coverage-repo
          
          # Configure git
          git config --global user.email "action@github.com"
          git config --global user.name "GitHub Action"
          
          # Copy the new coverage file
          cp ../coverage-${REPO_NAME}.txt .
          
          # Commit and push changes
          git add coverage-${REPO_NAME}.txt
          if git diff --cached --quiet; then
            echo "âœ… No changes to commit."
            exit 0
          fi
          git commit -m "chore: Update coverage report for ${REPO_NAME} from CI"
          git push origin main

  coverage-badge:
    name: Update coverage badge on README
    runs-on: ubuntu-latest
    needs: [main-coverage]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download coverage artifact
        uses: actions/download-artifact@v4
        with:
          name: code-coverage
          path: .

      - name: Generate Go Coverage Badge
        id: generate-badge
        uses: tj-actions/coverage-badge-go@v3
        with:
          filename: coverage.out

      - name: Verify Changed README
        if: steps.generate-badge.outcome == 'success'
        id: verify-changed-readme
        run: |
          git fetch origin main
          if git diff --quiet origin/main -- README.md; then
            echo "README.md has NOT changed."
            echo "readme_changed=false" >> $GITHUB_ENV
          else
            echo "README.md has changed."
            echo "readme_changed=true" >> $GITHUB_ENV
          fi

      - name: Commit changes
        if: env.readme_changed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git fetch origin main
          git checkout main
          git pull origin main

          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          git add README.md
          git commit -m "chore: Updated coverage badge. [skip ci]" || echo "No changes to commit"
          git push origin main